/*
Copyright (C) 2017, Battelle Memorial Institute
All rights reserved.

This software was co-developed by Pacific Northwest National Laboratory, operated by the Battelle Memorial
Institute; the National Renewable Energy Laboratory, operated by the Alliance for Sustainable Energy, LLC; and the
Lawrence Livermore National Laboratory, operated by Lawrence Livermore National Security, LLC.

*/
#ifndef _HELICS_FILTER_H_
#define _HELICS_FILTER_H_
#pragma once

#include "Federate.h"
#include "libguarded/guarded.hpp"
#include "../core/core.h"
#include <set>

namespace helics
{
class MessageTimeOperator;
class MessageConditionalOperator;
class MessageDestOperator;

/** class for managing filter operations*/
class FilterOperations
{
  public:
    FilterOperations () = default;
    virtual ~FilterOperations () = default;
    /** set a property on a filter
    @param property the name of the property of the filter to change
    @param val the numerical value of the property
    */
    virtual void set (const std::string &property, double val);
    /** set a string property on a filter
    @param property the name of the property of the filter to change
    @param val the numerical value of the property
    */
    virtual void setString (const std::string &property, const std::string &val);
    virtual std::shared_ptr<FilterOperator> getOperator () = 0;
};

/**filter for delaying a message in time*/
class delayFilterOperation : public FilterOperations
{
  private:
    std::atomic<Time> delay{timeZero};
    std::shared_ptr<MessageTimeOperator> td;

  public:
    delayFilterOperation (Time delayTime = timeZero);
    virtual void set (const std::string &property, double val) override;
    virtual std::shared_ptr<FilterOperator> getOperator () override;
};

class randomDelayGenerator;

/** filter for generating a random delay time for a message*/
class randomDelayFilterOperation : public FilterOperations
{
  private:
    std::shared_ptr<MessageTimeOperator> td;
    std::unique_ptr<randomDelayGenerator> rdelayGen;

  public:
    randomDelayFilterOperation ();
    ~randomDelayFilterOperation ();
    virtual void set (const std::string &property, double val) override;
    virtual void setString (const std::string &property, const std::string &val) override;
    virtual std::shared_ptr<FilterOperator> getOperator () override;
};

/** filter for randomly dropping a packet*/
class randomDropFilterOperation : public FilterOperations
{
  private:
    std::atomic<double> dropProb{0.0};
    std::shared_ptr<MessageConditionalOperator> tcond;

  public:
    randomDropFilterOperation ();
    ~randomDropFilterOperation ();
    virtual void set (const std::string &property, double val) override;
    virtual void setString (const std::string &property, const std::string &val) override;
    virtual std::shared_ptr<FilterOperator> getOperator () override;
};

/** filter for rerouting a packet to a particular endpoint*/
class rerouteFilterOperation : public FilterOperations
{
  private:
    std::shared_ptr<MessageDestOperator> op;  //!< the actual operator
    libguarded::guarded<std::string> newTarget;  //!< the target destination
    libguarded::guarded<std::set<std::string>> conditions; //!< the original destination must match one of these conditions
  public:
    rerouteFilterOperation ();
    ~rerouteFilterOperation ();
    virtual void set (const std::string &property, double val) override;
    virtual void setString (const std::string &property, const std::string &val) override;
    virtual std::shared_ptr<FilterOperator> getOperator () override;
};

/** class for managing a particular filter*/
class Filter
{
  protected:
    Core *corePtr = nullptr; //!< the Core to use
    Core::Handle id = invalid_Handle;  //!< the id as generated by the Federate
    filter_id_t fid = invalid_id_value;  //!< id for interacting with a federate
    std::shared_ptr<FilterOperations> filtOp;  //!< a class running any specific operation of the Filter
  public:
    Filter () = default;
    explicit Filter(Federate *mfed);
    explicit Filter(Core *cr);
    virtual ~Filter () = default;

    /** set a message operator to process the message*/
    void setOperator (std::shared_ptr<FilterOperator> mo);

    void setFilterOperations (std::shared_ptr<FilterOperations> filterOps);
};
/** class wrapping a source filter*/
class SourceFilter : public Filter
{
  public:
    /**constructor to build an source filter object
    @param[in] mFed  the Federate to use
    @param[in] target the endpoint the filter is targeting
    @param[in] name the name of the filter
    @param[in] input_type the type of data the filter is expecting
    @param[in] output_type the type of data the filter is generating
    */
      SourceFilter(Federate *mFed,
          const std::string &target,
          const std::string &name = "",
          const std::string &input_type = "",
          const std::string &output_type = "");
    /**constructor to build an source filter object
    @param[in] mFed  the Federate to use
    @param[in] target the endpoint the filter is targeting
    @param[in] name the name of the filter
    @param[in] input_type the type of data the filter is expecting
    @param[in] output_type the type of data the filter is generating
    */
      SourceFilter(Core *cr,
          const std::string &target,
          const std::string &name = "",
          const std::string &input_type = "",
          const std::string &output_type = "");
    virtual ~SourceFilter () = default;
};

/** class wrapping a destination filter*/
class DestinationFilter : public Filter
{
  public:
    /**constructor to build an destination filter object
    @param[in] mFed  the MessageFederate to use
    @param[in] target the endpoint the filter is targeting
    @param[in] name the name of the filter
    @param[in] input_type the type of data the filter is expecting
    @param[in] output_type the type of data the filter is generating
    */
      DestinationFilter(Federate *mFed,
          const std::string &target,
          const std::string &name = "",
          const std::string &input_type = "",
          const std::string &output_type = "");
      /**constructor to build an destination filter object
      @param[in] cr  the Core to register the filter with
      @param[in] target the endpoint the filter is targeting
      @param[in] name the name of the filter
      @param[in] input_type the type of data the filter is expecting
      @param[in] output_type the type of data the filter is generating
      */
      DestinationFilter(Core *cr,
          const std::string &target,
          const std::string &name = "",
          const std::string &input_type = "",
          const std::string &output_type = "");
    virtual ~DestinationFilter () = default;
};

enum defined_filter_types
{
    custom = 0,
    delay = 1,
    randomDelay = 2,
    randomDrop = 3,
    reroute = 4,

};

std::unique_ptr<DestinationFilter> make_destination_filter (defined_filter_types type,
                                                            Federate *mFed,
                                                            const std::string &target,
                                                            const std::string &name = "");

std::unique_ptr<SourceFilter> make_Source_filter (defined_filter_types type,
                                                  Federate *mFed,
                                                  const std::string &target,
                                                  const std::string &name = "");

std::unique_ptr<DestinationFilter> make_destination_filter(defined_filter_types type,
    Core *cr,
    const std::string &target,
    const std::string &name = "");

std::unique_ptr<SourceFilter> make_Source_filter(defined_filter_types type,
    Core *cr,
    const std::string &target,
    const std::string &name = "");

}  // namespace helics
#endif

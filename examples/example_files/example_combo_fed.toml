#this should be a valid json file (except comments are not recognized in standard JSON)
#example json configuration file for a message federate all arguments are optional
name="comboFed" # the name of the federate
#possible flags
observer=false  # indicator that the federate does not send anything
rollback= false # indicator that the federate can use rollback -NOTE= not used at present
only_update_on_change=false #indicator that the federate should only indicate updated values on change
only_transmit_on_change=false  #indicator that the federate should only publish if the value changed
source_only=false  #indicator that the federate is only a source and is not expected to receive anything
uninterruptible=false #indicator that the federate should only return requested times
coretype="inproc" #the type of the core "inproc","zmq","udp","ipc","tcp","mpi"
corename="the name of the core" #this matters most for ipc and inproc cores, can be empty
coreinit="1 --autobroker" # the initialization string for the core in the form of a command line arguments
max_iterations=10 #the maximum number of iterations for a time step
period=  1.0 #the period with which federate may return time
offset= 0.0 # the offset shift in the period
time_delta=0.0 # the minimum time between subsequent return times
output_delay=0 #the propagation delay for federates to send data
input_delay=0 #the input delay for external data to propagate to federates

#endpoints used in the federate
[[endpoints]]

name="ept1" # the name of the publication
 type="genmessage" # the type associated with a endpoint endpoint types have limited usefulness at present (optional)
 global=true #set to true to make the key global (default is false in which case the publication is prepended with the federate name)
[[endpoints]]
name="ept2" # the name of the publication
 type="message2" # the type associated with a endpoint (optional)
 #the fact that there is no global value creates a local endpoint with global name comboFed/ept2

 knownDestinations="ept1" #this value can be an array of strings or just a single one it names key paths
 #knownDestinations can be used to optimize the communication pathways inside of HELICS
 subscriptions="pub1"  #subscribe an endpoint to a particular publication  this means that an endpoint will get a message whenever anything is published to that particular key
 #the message will be raw data so it would have to be translated to be useful. this can also be a json array to subscribe to multiple publications

#Publications used in the federate
[[publications]]

"key"="pub1" # the name of the publication
 "type"="double" # the type associated with a publication (optional)
 "unit"="m"  # the units associated with a publication (optional)
 "global"=true #set to true to make the key global (default is false in which case the publication is prepended with the federate name)

[[publications]]
name="pub2" # the name of the publication (can be key or name)
 type="double" # the type associated with a publication (optional)
 info='{"field1":45,"field2":99}'  #literal info field
 #no global=true implies this will have the federate name prepended like comboFed/pub2

#subscriptions used in the federate
[[subscriptions]]

key="pub1" # the key of the publication
 type="double" # the type associated with a publication (optional)
 required=true #set to true to make helics issue a warning if the publication is not found

[[subscriptions]]
key="comboFed/pub2" # the name of the publication to subscribe to
shortcut="pubshortcut"  #a naming shortcut for the publication for later retrieval

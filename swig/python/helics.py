# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_helics')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_helics')
    _helics = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_helics', [dirname(__file__)])
        except ImportError:
            import _helics
            return _helics
        try:
            _mod = imp.load_module('_helics', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _helics = swig_import_helper()
    del swig_import_helper
else:
    import _helics
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

helics_ok = _helics.helics_ok
helics_invalid_object = _helics.helics_invalid_object
helics_invalid_argument = _helics.helics_invalid_argument
helics_discard = _helics.helics_discard
helics_terminated = _helics.helics_terminated
helics_warning = _helics.helics_warning
helics_invalid_state_transition = _helics.helics_invalid_state_transition
helics_invalid_function_call = _helics.helics_invalid_function_call
helics_error = _helics.helics_error
no_iteration = _helics.no_iteration
force_iteration = _helics.force_iteration
iterate_if_needed = _helics.iterate_if_needed
next_step = _helics.next_step
iteration_error = _helics.iteration_error
iteration_halted = _helics.iteration_halted
iterating = _helics.iterating
helics_startup_state = _helics.helics_startup_state
helics_initialization_state = _helics.helics_initialization_state
helics_execution_state = _helics.helics_execution_state
helics_finalize_state = _helics.helics_finalize_state
helics_error_state = _helics.helics_error_state
helics_pending_init_state = _helics.helics_pending_init_state
helics_pending_exec_state = _helics.helics_pending_exec_state
helics_pending_time_state = _helics.helics_pending_time_state
helics_pending_iterative_time_state = _helics.helics_pending_iterative_time_state
helics_custom_filter = _helics.helics_custom_filter
helics_delay_filter = _helics.helics_delay_filter
helics_randomDelay_filter = _helics.helics_randomDelay_filter
helics_randomDrop_filter = _helics.helics_randomDrop_filter
helics_reroute_filter = _helics.helics_reroute_filter
helics_clone_filter = _helics.helics_clone_filter
class data_t(_object):
    """


    Data to be communicated.

    Core operates on opaque byte buffers.

    C++ includes: api-data.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, data_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, data_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _helics.data_t_data_set
    __swig_getmethods__["data"] = _helics.data_t_data_get
    if _newclass:
        data = _swig_property(_helics.data_t_data_get, _helics.data_t_data_set)
    __swig_setmethods__["length"] = _helics.data_t_length_set
    __swig_getmethods__["length"] = _helics.data_t_length_get
    if _newclass:
        length = _swig_property(_helics.data_t_length_get, _helics.data_t_length_set)

    def __init__(self):
        """


        Data to be communicated.

        Core operates on opaque byte buffers.

        C++ includes: api-data.h

        """
        this = _helics.new_data_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _helics.delete_data_t
    __del__ = lambda self: None
data_t_swigregister = _helics.data_t_swigregister
data_t_swigregister(data_t)
cvar = _helics.cvar
helics_time_zero = cvar.helics_time_zero
helics_time_epsilon = cvar.helics_time_epsilon
helics_true = cvar.helics_true
helics_false = cvar.helics_false

class message_t(_object):
    """


    Message_t mapped to a c compatible structure

    C++ includes: api-data.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, message_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, message_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["time"] = _helics.message_t_time_set
    __swig_getmethods__["time"] = _helics.message_t_time_get
    if _newclass:
        time = _swig_property(_helics.message_t_time_get, _helics.message_t_time_set)
    __swig_setmethods__["data"] = _helics.message_t_data_set
    __swig_getmethods__["data"] = _helics.message_t_data_get
    if _newclass:
        data = _swig_property(_helics.message_t_data_get, _helics.message_t_data_set)
    __swig_setmethods__["length"] = _helics.message_t_length_set
    __swig_getmethods__["length"] = _helics.message_t_length_get
    if _newclass:
        length = _swig_property(_helics.message_t_length_get, _helics.message_t_length_set)
    __swig_setmethods__["original_source"] = _helics.message_t_original_source_set
    __swig_getmethods__["original_source"] = _helics.message_t_original_source_get
    if _newclass:
        original_source = _swig_property(_helics.message_t_original_source_get, _helics.message_t_original_source_set)
    __swig_setmethods__["source"] = _helics.message_t_source_set
    __swig_getmethods__["source"] = _helics.message_t_source_get
    if _newclass:
        source = _swig_property(_helics.message_t_source_get, _helics.message_t_source_set)
    __swig_setmethods__["dest"] = _helics.message_t_dest_set
    __swig_getmethods__["dest"] = _helics.message_t_dest_get
    if _newclass:
        dest = _swig_property(_helics.message_t_dest_get, _helics.message_t_dest_set)
    __swig_setmethods__["original_dest"] = _helics.message_t_original_dest_set
    __swig_getmethods__["original_dest"] = _helics.message_t_original_dest_get
    if _newclass:
        original_dest = _swig_property(_helics.message_t_original_dest_get, _helics.message_t_original_dest_set)

    def __init__(self):
        """


        Message_t mapped to a c compatible structure

        C++ includes: api-data.h

        """
        this = _helics.new_message_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _helics.delete_message_t
    __del__ = lambda self: None
message_t_swigregister = _helics.message_t_swigregister
message_t_swigregister(message_t)

HELICS_CORE_TYPE_DEFAULT = _helics.HELICS_CORE_TYPE_DEFAULT
HELICS_CORE_TYPE_ZMQ = _helics.HELICS_CORE_TYPE_ZMQ
HELICS_CORE_TYPE_MPI = _helics.HELICS_CORE_TYPE_MPI
HELICS_CORE_TYPE_TEST = _helics.HELICS_CORE_TYPE_TEST
HELICS_CORE_TYPE_INTERPROCESS = _helics.HELICS_CORE_TYPE_INTERPROCESS
HELICS_CORE_TYPE_IPC = _helics.HELICS_CORE_TYPE_IPC
HELICS_CORE_TYPE_TCP = _helics.HELICS_CORE_TYPE_TCP
HELICS_CORE_TYPE_UDP = _helics.HELICS_CORE_TYPE_UDP

def helicsGetVersion():
    """


    """
    return _helics.helicsGetVersion()

def helicsIsCoreTypeAvailable(type):
    """


    Returns true if core/broker type specified is available in current compilation.

    """
    return _helics.helicsIsCoreTypeAvailable(type)

def helicsCreateCore(type, name, initString):
    """


    create a core object

    Parameters
    ----------
    * `type` :
        the type of the core to create
    * `name` :
        the name of the core , may be a nullptr or empty string to have a name
        automatically assigned
    * `initString` :
        an initialization string to send to the core-the format is similar to
        command line arguments typical options include a broker address
        --broker="XSSAF" or the number of federates or the address

    Returns
    -------
    a helics_core object

    """
    return _helics.helicsCreateCore(type, name, initString)

def helicsCreateCoreFromArgs(type, name, argc, argv):
    """


    create a core object by passing command line arguments

    Parameters
    ----------
    * `type` :
        the type of the core to create
    * `name` :
        the name of the core , may be a nullptr or empty string to have a name
        automatically assigned
    * `argc` :
        the number of arguments
    * `argv` :
        the string values from a command line

    Returns
    -------
    a helics_core object

    """
    return _helics.helicsCreateCoreFromArgs(type, name, argc, argv)

def helicsCoreClone(core):
    return _helics.helicsCoreClone(core)
helicsCoreClone = _helics.helicsCoreClone

def helicsCreateBroker(type, name, initString):
    """


    create a broker object

    Parameters
    ----------
    * `type` :
        the type of the broker to create
    * `name` :
        the name of the broker , may be a nullptr or empty string to have a name
        automatically assigned
    * `initString` :
        an initialization string to send to the core-the format is similar to
        command line arguments typical options include a broker address
        --broker="XSSAF" if this is a subbroker or the number of federates or the
        address

    Returns
    -------
    a helics_core object

    """
    return _helics.helicsCreateBroker(type, name, initString)

def helicsCreateBrokerFromArgs(type, name, argc, argv):
    """


    create a core object by passing command line arguments

    Parameters
    ----------
    * `type` :
        the type of the core to create
    * `name` :
        the name of the core , may be a nullptr or empty string to have a name
        automatically assigned
    * `argc` :
        the number of arguments
    * `argv` :
        the string values from a command line

    Returns
    -------
    a helics_core object

    """
    return _helics.helicsCreateBrokerFromArgs(type, name, argc, argv)

def helicsBrokerClone(broker):
    return _helics.helicsBrokerClone(broker)
helicsBrokerClone = _helics.helicsBrokerClone

def helicsBrokerIsConnected(broker):
    """


    check if a broker is connected a connected broker implies is attached to cores
    or cores could reach out to communicate return 0 if not connected , something
    else if it is connected

    """
    return _helics.helicsBrokerIsConnected(broker)

def helicsCoreIsConnected(core):
    """


    check if a core is connected a connected core implies is attached to federate or
    federates could be attached to it return 0 if not connected , something else if
    it is connected

    """
    return _helics.helicsCoreIsConnected(core)

def helicsBrokerGetIdentifier(broker, identifier, maxlen):
    """


    get an identifier for the broker

    Parameters
    ----------
    * `broker` :
        the broker to query
    * `identifier` :
        storage space to place the identifier string
    * `maxlen` :
        the maximum space available in identifier

    Returns
    -------
    a helics_status enumeration indicating any error condition

    """
    return _helics.helicsBrokerGetIdentifier(broker, identifier, maxlen)

def helicsCoreGetIdentifier(core, identifier, maxlen):
    """


    get an identifier for the core

    Parameters
    ----------
    * `core` :
        the core to query
    * `identifier` :
        storage space to place the identifier string
    * `maxlen` :
        the maximum space available in identifier

    Returns
    -------
    a helics_status enumeration indicating any error condition

    """
    return _helics.helicsCoreGetIdentifier(core, identifier, maxlen)

def helicsBrokerGetAddress(broker, address, maxlen):
    """


    get the network address associated with a broker

    Parameters
    ----------
    * `broker` :
        the broker to query
    * `identifier` :
        storage space to place the identifier string
    * `maxlen` :
        the maximum space available in identifier

    Returns
    -------
    a helics_status enumeration indicating any error condition

    """
    return _helics.helicsBrokerGetAddress(broker, address, maxlen)

def helicsCoreSetReadyToInit(core):
    return _helics.helicsCoreSetReadyToInit(core)
helicsCoreSetReadyToInit = _helics.helicsCoreSetReadyToInit

def helicsCoreDisconnect(core):
    """


    get an identifier for the core

    Parameters
    ----------
    * `core` :
        the core to query
    * `identifier` :
        storage space to place the identifier string
    * `maxlen` :
        the maximum space available in identifier

    Returns
    -------
    a helics_status enumeration indicating any error condition

    """
    return _helics.helicsCoreDisconnect(core)

def helicsGetFederateByName(fedName):
    return _helics.helicsGetFederateByName(fedName)
helicsGetFederateByName = _helics.helicsGetFederateByName

def helicsBrokerDisconnect(broker):
    """


    get the network address associated with a broker

    Parameters
    ----------
    * `broker` :
        the broker to query
    * `identifier` :
        storage space to place the identifier string
    * `maxlen` :
        the maximum space available in identifier

    Returns
    -------
    a helics_status enumeration indicating any error condition

    """
    return _helics.helicsBrokerDisconnect(broker)

def helicsCoreFree(core):
    """


    release the memory associated with a core

    """
    return _helics.helicsCoreFree(core)

def helicsBrokerFree(broker):
    """


    release the memory associated with a broker

    """
    return _helics.helicsBrokerFree(broker)

def helicsCreateValueFederate(fi):
    """


    create a value federate from a federate info object

    helics_federate objects can be used in all functions that take a helics_federate
    or helics_federate object as an argument

    Parameters
    ----------
    * `fi` :
        the federate info object that contains details on the federate

    Returns
    -------
    an opaque value federate object

    """
    return _helics.helicsCreateValueFederate(fi)

def helicsCreateValueFederateFromJson(json):
    """


    create a value federate from a JSON file or JSON string

    helics_federate objects can be used in all functions that take a helics_federate
    or helics_federate object as an argument

    Parameters
    ----------
    * `JSON` :
        a JSON file or a JSON string that contains setup and configuration
        information

    Returns
    -------
    an opaque value federate object

    """
    return _helics.helicsCreateValueFederateFromJson(json)

def helicsCreateMessageFederate(fi):
    """


    create a message federate from a federate info object

    helics_message_federate objects can be used in all functions that take a
    helics_message_federate or helics_federate object as an argument

    Parameters
    ----------
    * `fi` :
        the federate info object that contains details on the federate

    Returns
    -------
    an opaque message federate object

    """
    return _helics.helicsCreateMessageFederate(fi)

def helicsCreateMessageFederateFromJson(json):
    """


    create a message federate from a JSON file or JSON string

    helics_message_federate objects can be used in all functions that take a
    helics_message_federate or helics_federate object as an argument

    Parameters
    ----------
    * `JSON` :
        a JSON file or a JSON string that contains setup and configuration
        information

    Returns
    -------
    an opaque message federate object

    """
    return _helics.helicsCreateMessageFederateFromJson(json)

def helicsCreateCombinationFederate(fi):
    """


    create a combination federate from a federate info object

    combination federates are both value federates and message federates, objects
    can be used in all functions that take a helics_federate,
    helics_message_federate or helics_federate object as an argument

    Parameters
    ----------
    * `fi` :
        the federate info object that contains details on the federate

    Returns
    -------
    an opaque value federate object nullptr if the object creation failed

    """
    return _helics.helicsCreateCombinationFederate(fi)

def helicsCreateCombinationFederateFromJson(json):
    """


    create a combination federate from a JSON file or JSON string

    combination federates are both value federates and message federates, objects
    can be used in all functions that take a helics_federate,
    helics_message_federate or helics_federate object as an argument

    Parameters
    ----------
    * `JSON` :
        a JSON file or a JSON string that contains setup and configuration
        information

    Returns
    -------
    an opaque combination federate object

    """
    return _helics.helicsCreateCombinationFederateFromJson(json)

def helicsFederateClone(fed):
    return _helics.helicsFederateClone(fed)
helicsFederateClone = _helics.helicsFederateClone

def helicsFederateInfoCreate():
    """


    create a federate info object for specifying federate information when
    constructing a federate

    Returns
    -------
    a helics_federate_info_t object which is a reference to the created object

    """
    return _helics.helicsFederateInfoCreate()

def helicsFederateInfoLoadFromArgs(fi, argc, argv):
    """


    load a federate info from command line arguments

    Parameters
    ----------
    * `fi` :
        a federateInfo object
    * `argc` :
        the number of command line arguments
    * `argv` :
        an array of strings from the command line

    Returns
    -------
    a helics_status enumeration indicating success or any potential errors

    """
    return _helics.helicsFederateInfoLoadFromArgs(fi, argc, argv)

def helicsFederateInfoFree(fi):
    """


    delete the memory associated with a federate info object

    """
    return _helics.helicsFederateInfoFree(fi)

def helicsFederateInfoSetFederateName(fi, name):
    """


    set the federate name in the Federate Info structure

    Parameters
    ----------
    * `fi` :
        the federate info object to alter
    * `name` :
        the new identifier for the federate

    Returns
    -------
    a helics_status enumeration helics_ok on success

    """
    return _helics.helicsFederateInfoSetFederateName(fi, name)

def helicsFederateInfoSetCoreName(fi, corename):
    """


    set the name of the core to link to for a federate

    Parameters
    ----------
    * `fi` :
        the federate info object to alter
    * `corename` :
        the identifier for a core to link to

    Returns
    -------
    a helics_status enumeration helics_ok on success helicsInvalidReference if fi is
    not a valid reference

    """
    return _helics.helicsFederateInfoSetCoreName(fi, corename)

def helicsFederateInfoSetCoreInitString(fi, coreInit):
    """


    set the initialization string for the core usually in the form of command line
    arguments

    Parameters
    ----------
    * `fi` :
        the federate info object to alter
    * `coreInit` :
        a string with the core initialization strings

    Returns
    -------
    a helics_status enumeration helics_ok on success helicsInvalidReference if fi is
    not a valid reference

    """
    return _helics.helicsFederateInfoSetCoreInitString(fi, coreInit)

def helicsFederateInfoSetCoreTypeFromString(fi, coretype):
    """


    set the core type from a string

    Parameters
    ----------
    * `fi` :
        the federate info object to alter
    * `coretype` :
        a string naming a core type

    Returns
    -------
    a helics_status enumeration helics_ok on success helicsInvalidReference if fi is
    not a valid reference helics_discard if the string is not recognized

    """
    return _helics.helicsFederateInfoSetCoreTypeFromString(fi, coretype)

def helicsFederateInfoSetCoreType(fi, coretype):
    """


    """
    return _helics.helicsFederateInfoSetCoreType(fi, coretype)

def helicsFederateInfoSetFlag(fi, flag, value):
    """


    """
    return _helics.helicsFederateInfoSetFlag(fi, flag, value)

def helicsFederateInfoSetOutputDelay(fi, outputDelay):
    """


    """
    return _helics.helicsFederateInfoSetOutputDelay(fi, outputDelay)

def helicsFederateInfoSetTimeDelta(fi, timeDelta):
    """


    """
    return _helics.helicsFederateInfoSetTimeDelta(fi, timeDelta)

def helicsFederateInfoSetInputDelay(fi, inputDelay):
    """


    """
    return _helics.helicsFederateInfoSetInputDelay(fi, inputDelay)

def helicsFederateInfoSetTimeOffset(fi, timeOffset):
    """


    """
    return _helics.helicsFederateInfoSetTimeOffset(fi, timeOffset)

def helicsFederateInfoSetPeriod(fi, period):
    """


    """
    return _helics.helicsFederateInfoSetPeriod(fi, period)

def helicsFederateInfoSetMaxIterations(fi, maxIterations):
    """


    """
    return _helics.helicsFederateInfoSetMaxIterations(fi, maxIterations)

def helicsFederateInfoSetLoggingLevel(fi, logLevel):
    """


    """
    return _helics.helicsFederateInfoSetLoggingLevel(fi, logLevel)

def helicsFederateFinalize(fed):
    """


    finalize the federate this halts all communication in the federate and
    disconnects it from the core

    """
    return _helics.helicsFederateFinalize(fed)

def helicsFederateFree(fed):
    """


    release the memory associated withe a federate

    """
    return _helics.helicsFederateFree(fed)

def helicsCloseLibrary():
    """


    call when done using the helics library, this function will ensure the threads
    are closed properly if possible this should be the last call before exiting,

    """
    return _helics.helicsCloseLibrary()

def helicsFederateEnterInitializationMode(fed):
    """


    enter the initialization state of a federate

    the initialization state allows initial values to be set and received if the
    iteration is requested on entry to the execution state This is a blocking call
    and will block until the core allows it to proceed

    """
    return _helics.helicsFederateEnterInitializationMode(fed)

def helicsFederateEnterInitializationModeAsync(fed):
    """


    non blocking alternative to  the function
    helicsFederateEnterInitializationModeFinalize must be called to finish the
    operation

    """
    return _helics.helicsFederateEnterInitializationModeAsync(fed)

def helicsFederateIsAsyncOperationCompleted(fed):
    """


    check if the current Asynchronous operation has completed

    Parameters
    ----------
    * `fed` :
        the federate to operate on

    Returns
    -------
    0 if not completed, 1 if completed

    """
    return _helics.helicsFederateIsAsyncOperationCompleted(fed)

def helicsFederateEnterInitializationModeComplete(fed):
    """


    finalize the entry to initialize mode that was initiated with

    """
    return _helics.helicsFederateEnterInitializationModeComplete(fed)

def helicsFederateEnterExecutionMode(fed):
    """


    request that the federate enter the Execution mode

    this call is blocking until granted entry by the core object for an asynchronous
    alternative call /ref helicsFederateEnterExecutionModeAsync

    Parameters
    ----------
    * `fed` :
        a federate to change modes

    Returns
    -------
    a helics_status enumeration helics_error if something went wrong
    helicsInvalidReference if fed is invalid

    """
    return _helics.helicsFederateEnterExecutionMode(fed)

def helicsFederateEnterExecutionModeAsync(fed):
    """


    request that the federate enter the Execution mode

    this call is non-blocking and will return immediately call /ref
    helicsFederateEnterExecutionModeComplete to finish the call sequence /ref

    """
    return _helics.helicsFederateEnterExecutionModeAsync(fed)

def helicsFederateEnterExecutionModeComplete(fed):
    """


    complete the call to /ref EnterExecutionModeAsync

    Parameters
    ----------
    * `fed` :
        the federate object to complete the call

    """
    return _helics.helicsFederateEnterExecutionModeComplete(fed)

def helicsFederateEnterExecutionModeIterative(fed, iterate):
    """


    """
    return _helics.helicsFederateEnterExecutionModeIterative(fed, iterate)

def helicsFederateEnterExecutionModeIterativeAsync(fed, iterate):
    """


    """
    return _helics.helicsFederateEnterExecutionModeIterativeAsync(fed, iterate)

def helicsFederateEnterExecutionModeIterativeComplete(fed):
    """


    """
    return _helics.helicsFederateEnterExecutionModeIterativeComplete(fed)

def helicsFederateGetState(fed):
    """


    get the current state of a federate

    Parameters
    ----------
    * `fed` :
        the fed to query
    * `state` :
        the resulting state if helics_status return helics_ok

    """
    return _helics.helicsFederateGetState(fed)

def helicsFederateGetCoreObject(fed):
    """


    get the core object associated with a federate

    Parameters
    ----------
    * `fed` :
        a federate object

    Returns
    -------
    a core object, nullptr if invalid

    """
    return _helics.helicsFederateGetCoreObject(fed)

def helicsFederateRequestTime(fed, requestTime):
    """


    request the next time for federate execution

    Parameters
    ----------
    * `fed` :
        the federate to make the request of
    * `requestTime` :
        the next requested time
    * `timeOut` :
        the time granted to the federate

    Returns
    -------
    a helics_status if the return value is equal to helics_ok the timeOut will
    contain the new granted time, otherwise timeOut is invalid

    """
    return _helics.helicsFederateRequestTime(fed, requestTime)

def helicsFederateRequestTimeIterative(fed, requestTime, iterate):
    """


    request an iterative time

    this call allows for finer grain control of the iterative process then /ref
    helicsFederateRequestTime it takes a time and and iteration request and return a
    time and iteration status

    Parameters
    ----------
    * `fed` :
        the federate to make the request of
    * `requestTime` :
        the next desired time
    * `iterate` :
        the requested iteration mode
    * `timeOut` :
        the granted time
    * `outIterate` :
        the iteration specification of the result

    Returns
    -------
    a helics_status object with a return code of the result

    """
    return _helics.helicsFederateRequestTimeIterative(fed, requestTime, iterate)

def helicsFederateRequestTimeAsync(fed, requestTime):
    """


    """
    return _helics.helicsFederateRequestTimeAsync(fed, requestTime)

def helicsFederateRequestTimeComplete(fed):
    """


    """
    return _helics.helicsFederateRequestTimeComplete(fed)

def helicsFederateRequestTimeIterativeAsync(fed, requestTime, iterate):
    """


    """
    return _helics.helicsFederateRequestTimeIterativeAsync(fed, requestTime, iterate)

def helicsFederateRequestTimeIterativeComplete(fed):
    """


    """
    return _helics.helicsFederateRequestTimeIterativeComplete(fed)

def helicsFederateGetName(fed, str):
    """


    get the name of the federate

    Parameters
    ----------
    * `fed` :
        the federate object to query
    * `str` :
        memory buffer to store the result
    * `maxlen` :
        the maximum size of the buffer

    Returns
    -------
    helics_status object indicating success or error

    """
    return _helics.helicsFederateGetName(fed, str)

def helicsFederateSetTimeDelta(fed, time):
    """


    set the minimum time delta for the federate

    Parameters
    ----------
    * `tdelta` :
        the minimum time delta to return from a time request function

    """
    return _helics.helicsFederateSetTimeDelta(fed, time)

def helicsFederateSetOutputDelay(fed, outputDelay):
    """


    set the look ahead time

    the look ahead is the propagation time for messages/event to propagate from the
    Federate the federate

    Parameters
    ----------
    * `lookAhead` :
        the look ahead time

    """
    return _helics.helicsFederateSetOutputDelay(fed, outputDelay)

def helicsFederateSetInputDelay(fed, inputDelay):
    """


    set the impact Window time

    the impact window is the time window around the time request in which other
    federates cannot affect the federate

    Parameters
    ----------
    * `lookAhead` :
        the look ahead time

    """
    return _helics.helicsFederateSetInputDelay(fed, inputDelay)

def helicsFederateSetPeriod(fed, period, offset):
    """


    set the period and offset of the federate

    the federate will on grant time on N*period+offset interval

    Parameters
    ----------
    * `period` :
        the length of time between each subsequent grants
    * `offset` :
        the shift of the period from 0 offset must be < period

    """
    return _helics.helicsFederateSetPeriod(fed, period, offset)

def helicsFederateSetFlag(fed, flag, flagValue):
    """


    set a flag for the federate

    Parameters
    ----------
    * `fed` :
        the federate to alter a flag for
    * `flag` :
        the flag to change
    * `flagValue` :
        the new value of the flag 0 for false !=0 for true

    """
    return _helics.helicsFederateSetFlag(fed, flag, flagValue)

def helicsFederateSetLoggingLevel(fed, loggingLevel):
    """


    set the logging level for the federate @ details debug and trace only do
    anything if they were enabled in the compilation

    Parameters
    ----------
    * `loggingLevel` :
        (-1: none, 0: error_only, 1: warnings, 2: normal, 3: debug, 4: trace)

    """
    return _helics.helicsFederateSetLoggingLevel(fed, loggingLevel)

def helicsFederateGetCurrentTime(fed):
    """


    get the current time of the federate

    Parameters
    ----------
    * `fed` :
        the federate object to query
    * `time` :
        storage location for the time variable

    Returns
    -------
    helics_status object indicating success or error

    """
    return _helics.helicsFederateGetCurrentTime(fed)

def helicsCreateQuery(target, query):
    """


    create a query object

    a query object consists of a target and query string

    """
    return _helics.helicsCreateQuery(target, query)

def helicsQueryExecute(query, fed):
    """


    Execute a query

    the call will block until the query finishes which may require communication or
    other delays

    Parameters
    ----------
    * `query` :
        the query object to use in the query
    * `fed` :
        a federate to send the query through

    Returns
    -------
    a pointer to a string. the string will remain valid until the query is freed or
    executed again the return will be nullptr if fed or query is an invalid object

    """
    return _helics.helicsQueryExecute(query, fed)

def helicsQueryExecuteAsync(query, fed):
    """


    Execute a query in a non-blocking call

    Parameters
    ----------
    * `query` :
        the query object to use in the query
    * `fed` :
        a federate to send the query through

    Returns
    -------
    a helics status enumeration with the result of the query specification

    """
    return _helics.helicsQueryExecuteAsync(query, fed)

def helicsQueryExecuteComplete(query):
    """


    complete the return from a query called with /ref helicsExecuteQueryAsync

    the function will block until the query completes /ref isQueryComplete can be
    called to determine if a query has completed or not

    Parameters
    ----------
    * `query` :
        the query object to

    Returns
    -------
    a pointer to a string. the string will remain valid until the query is freed or
    executed again the return will be nullptr if query is an invalid object

    """
    return _helics.helicsQueryExecuteComplete(query)

def helicsQueryIsCompleted(query):
    """


    check if an asynchronously executed query has completed

    Returns
    -------
    will return helics_true if an async query has complete or a regular query call
    was made with a result and false if an async query has not completed or is
    invalid

    """
    return _helics.helicsQueryIsCompleted(query)

def helicsQueryFree(arg1):
    """


    free the memory associated with a query object

    """
    return _helics.helicsQueryFree(arg1)

def helicsCleanupHelicsLibrary():
    return _helics.helicsCleanupHelicsLibrary()
helicsCleanupHelicsLibrary = _helics.helicsCleanupHelicsLibrary
HELICS_DATA_TYPE_STRING = _helics.HELICS_DATA_TYPE_STRING
HELICS_DATA_TYPE_DOUBLE = _helics.HELICS_DATA_TYPE_DOUBLE
HELICS_DATA_TYPE_INT = _helics.HELICS_DATA_TYPE_INT
HELICS_DATA_TYPE_COMPLEX = _helics.HELICS_DATA_TYPE_COMPLEX
HELICS_DATA_TYPE_VECTOR = _helics.HELICS_DATA_TYPE_VECTOR
HELICS_DATA_TYPE_RAW = _helics.HELICS_DATA_TYPE_RAW

def helicsFederateRegisterSubscription(fed, key, type, units):
    """


    create a subscription

    the subscription becomes part of the federate and is destroyed when the federate
    is freed so there are no separate free functions for subscriptions and
    publications

    Parameters
    ----------
    * `fed` :
        the federate object in which to create a subscription must have been create
        with helicsCreateValueFederate or helicsCreateCombinationFederate
    * `key` :
        the identifier matching a publication to get a subscription for
    * `type` :
        a string describing the expected type of the publication may be NULL
    * `units` :
        a string listing the units of the subscription maybe NULL

    Returns
    -------
    an object containing the subscription

    """
    return _helics.helicsFederateRegisterSubscription(fed, key, type, units)

def helicsFederateRegisterTypeSubscription(fed, key, type, units):
    """


    create a subscription of a specific known type

    the subscription becomes part of the federate and is destroyed when the federate
    is freed so there are no separate free functions for subscriptions and
    publications

    Parameters
    ----------
    * `fed` :
        the federate object in which to create a subscription
    * `key` :
        the identifier matching a publication to get a subscription for
    * `type` :
        a known type identifier HELICS_STRING_TYPE, HELICS_INT_TYPE,
        HELICS_DOUBLE_TYPE, HELICS_COMPLEX_TYPE, HELICS_VECTOR_TYPE, HELICS_RAW_TYPE
    * `units` :
        a string listing the units of the subscription maybe NULL

    Returns
    -------
    an object containing the subscription

    """
    return _helics.helicsFederateRegisterTypeSubscription(fed, key, type, units)

def helicsFederateRegisterOptionalSubscription(fed, key, type, units):
    """


    create a subscription that is specifically stated to be optional

    the subscription becomes part of the federate and is destroyed when the federate
    is freed so there are no separate free functions for subscriptions and
    publications

    optional implies that there may or may not be matching publication elsewhere in
    the federation

    Parameters
    ----------
    * `fed` :
        the federate object in which to create a subscription
    * `key` :
        the identifier matching a publication to get a subscription for
    * `type` :
        a string describing the expected type of the publication may be NULL
    * `units` :
        a string listing the units of the subscription maybe NULL

    Returns
    -------
    an object containing the subscription

    """
    return _helics.helicsFederateRegisterOptionalSubscription(fed, key, type, units)

def helicsFederateRegisterOptionalTypeSubscription(fed, key, type, units):
    """


    create a subscription of a specific known type that is specifically stated to be
    optional

    the subscription becomes part of the federate and is destroyed when the federate
    is freed so there are no separate free functions for subscriptions and
    publications optional implies that there may or may not be matching publication
    elsewhere in the federation

    Parameters
    ----------
    * `fed` :
        the federate object in which to create a subscription
    * `key` :
        the identifier matching a publication to get a subscription for
    * `type` :
        a known type identifier HELICS_STRING_TYPE, HELICS_INT_TYPE,
        HELICS_DOUBLE_TYPE, HELICS_COMPLEX_TYPE, HELICS_VECTOR_TYPE, HELICS_RAW_TYPE
    * `units` :
        a string listing the units of the subscription maybe NULL

    Returns
    -------
    an object containing the subscription

    """
    return _helics.helicsFederateRegisterOptionalTypeSubscription(fed, key, type, units)

def helicsFederateRegisterPublication(fed, key, type, units):
    """


    """
    return _helics.helicsFederateRegisterPublication(fed, key, type, units)

def helicsFederateRegisterTypePublication(fed, key, type, units):
    """


    """
    return _helics.helicsFederateRegisterTypePublication(fed, key, type, units)

def helicsFederateRegisterGlobalPublication(fed, key, type, units):
    """


    """
    return _helics.helicsFederateRegisterGlobalPublication(fed, key, type, units)

def helicsFederateRegisterGlobalTypePublication(fed, key, type, units):
    """


    """
    return _helics.helicsFederateRegisterGlobalTypePublication(fed, key, type, units)

def helicsPublicationPublish(pub, data):
    """


    """
    return _helics.helicsPublicationPublish(pub, data)

def helicsPublicationPublishString(pub, str):
    """


    """
    return _helics.helicsPublicationPublishString(pub, str)

def helicsPublicationPublishInteger(pub, val):
    """


    """
    return _helics.helicsPublicationPublishInteger(pub, val)

def helicsPublicationPublishDouble(pub, val):
    """


    """
    return _helics.helicsPublicationPublishDouble(pub, val)

def helicsPublicationPublishComplex(pub, real, imag):
    """


    """
    return _helics.helicsPublicationPublishComplex(pub, real, imag)

def helicsPublicationPublishVector(pub, data, len):
    """


    """
    return _helics.helicsPublicationPublishVector(pub, data, len)

def helicsSubscriptionGetValueSize(sub):
    """


    """
    return _helics.helicsSubscriptionGetValueSize(sub)

def helicsSubscriptionGetValue(sub, data, maxlen):
    """


    """
    return _helics.helicsSubscriptionGetValue(sub, data, maxlen)

def helicsSubscriptionGetString(sub, str):
    """


    """
    return _helics.helicsSubscriptionGetString(sub, str)

def helicsSubscriptionGetInteger(sub):
    """


    """
    return _helics.helicsSubscriptionGetInteger(sub)

def helicsSubscriptionGetDouble(sub):
    """


    """
    return _helics.helicsSubscriptionGetDouble(sub)

def helicsSubscriptionGetComplex(sub):
    """


    """
    return _helics.helicsSubscriptionGetComplex(sub)

def helicsSubscriptionGetVectorSize(sub):
    """


    """
    return _helics.helicsSubscriptionGetVectorSize(sub)

def helicsSubscriptionGetVector(sub, data, maxlen):
    """


    get a vector from a subscription

    Parameters
    ----------
    * `sub` :
        the subscription to get the result for
    * `data` :
        the location to store the data
    * `maxlen` :
        the maximum size of the vector
    * `actualSize` :
        pointer to variable to store the actual size

    """
    return _helics.helicsSubscriptionGetVector(sub, data, maxlen)

def helicsSubscriptionSetDefault(sub, data):
    """


    """
    return _helics.helicsSubscriptionSetDefault(sub, data)

def helicsSubscriptionSetDefaultString(sub, str):
    """


    """
    return _helics.helicsSubscriptionSetDefaultString(sub, str)

def helicsSubscriptionSetDefaultInteger(sub, val):
    """


    """
    return _helics.helicsSubscriptionSetDefaultInteger(sub, val)

def helicsSubscriptionSetDefaultDouble(sub, val):
    """


    """
    return _helics.helicsSubscriptionSetDefaultDouble(sub, val)

def helicsSubscriptionSetDefaultComplex(sub, real, imag):
    """


    """
    return _helics.helicsSubscriptionSetDefaultComplex(sub, real, imag)

def helicsSubscriptionSetDefaultVector(sub, len):
    """


    """
    return _helics.helicsSubscriptionSetDefaultVector(sub, len)

def helicsSubscriptionGetType(sub, str):
    """


    """
    return _helics.helicsSubscriptionGetType(sub, str)

def helicsPublicationGetType(pub, str):
    """


    """
    return _helics.helicsPublicationGetType(pub, str)

def helicsSubscriptionGetKey(sub, str):
    """


    """
    return _helics.helicsSubscriptionGetKey(sub, str)

def helicsPublicationGetKey(pub, str):
    """


    """
    return _helics.helicsPublicationGetKey(pub, str)

def helicsSubscriptionGetUnits(sub, str):
    """


    """
    return _helics.helicsSubscriptionGetUnits(sub, str)

def helicsPublicationGetUnits(pub, str):
    """


    """
    return _helics.helicsPublicationGetUnits(pub, str)

def helicsSubscriptionIsUpdated(sub):
    """


    """
    return _helics.helicsSubscriptionIsUpdated(sub)

def helicsSubscriptionLastUpdateTime(sub):
    """


    """
    return _helics.helicsSubscriptionLastUpdateTime(sub)

def helicsFederateGetPublicationCount(fed):
    return _helics.helicsFederateGetPublicationCount(fed)
helicsFederateGetPublicationCount = _helics.helicsFederateGetPublicationCount

def helicsFederateGetSubscriptionCount(fed):
    return _helics.helicsFederateGetSubscriptionCount(fed)
helicsFederateGetSubscriptionCount = _helics.helicsFederateGetSubscriptionCount

def helicsFederateRegisterEndpoint(fed, name, type):
    """


    """
    return _helics.helicsFederateRegisterEndpoint(fed, name, type)

def helicsFederateRegisterGlobalEndpoint(fed, name, type):
    """


    """
    return _helics.helicsFederateRegisterGlobalEndpoint(fed, name, type)

def helicsEndpointSetDefaultDestination(endpoint, dest):
    """


    """
    return _helics.helicsEndpointSetDefaultDestination(endpoint, dest)

def helicsEndpointSendMessageRaw(endpoint, dest, data):
    """


    """
    return _helics.helicsEndpointSendMessageRaw(endpoint, dest, data)

def helicsEndpointSendEventRaw(endpoint, dest, data, time):
    """


    """
    return _helics.helicsEndpointSendEventRaw(endpoint, dest, data, time)

def helicsEndpointSendMessage(endpoint, message):
    """


    """
    return _helics.helicsEndpointSendMessage(endpoint, message)

def helicsEndpointSubscribe(endpoint, key, type):
    """


    subscribe an endpoint to a publication

    Parameters
    ----------
    * `endpoint` :
        the endpoint to use
    * `key` :
        the name of the publication
    * `type` :
        the type of the publication that is expected (nullptr or "" for DON'T
        CARE)

    """
    return _helics.helicsEndpointSubscribe(endpoint, key, type)

def helicsFederateHasMessage(fed):
    """


    check if the federate has any outstanding messages

    """
    return _helics.helicsFederateHasMessage(fed)

def helicsEndpointHasMessage(endpoint):
    """


    """
    return _helics.helicsEndpointHasMessage(endpoint)

def helicsFederateReceiveCount(fed):
    """


    Returns the number of pending receives for the specified destination endpoint.

    """
    return _helics.helicsFederateReceiveCount(fed)

def helicsEndpointReceiveCount(endpoint):
    """


    Returns the number of pending receives for all endpoints of particular federate.

    """
    return _helics.helicsEndpointReceiveCount(endpoint)

def helicsEndpointGetMessage(endpoint):
    """


    receive a packet from a particular endpoint

    Parameters
    ----------
    * `endpoint` :
        the identifier for the endpoint

    Returns
    -------
    a message object

    """
    return _helics.helicsEndpointGetMessage(endpoint)

def helicsFederateGetMessage(fed):
    """


    receive a communication message for any endpoint in the federate

    the return order will be in order of endpoint creation then order of arrival all
    messages for the first endpoint, then all for the second, and so on

    Returns
    -------
    a unique_ptr to a Message object containing the message data

    """
    return _helics.helicsFederateGetMessage(fed)

def helicsEndpointGetType(endpoint, str):
    """


    get the type specified for an endpoint

    Parameters
    ----------
    * `endpoint` :
        the endpoint object in question
    * `str` :
        the location where the string is stored
    * `maxlen` :
        the maximum string length that can be stored in str

    Returns
    -------
    a status variable

    """
    return _helics.helicsEndpointGetType(endpoint, str)

def helicsEndpointGetName(endpoint, str):
    """


    get the name of an endpoint

    Parameters
    ----------
    * `endpoint` :
        the endpoint object in question
    * `str` :
        the location where the string is stored
    * `maxlen` :
        the maximum string length that can be stored in str

    Returns
    -------
    a status variable

    """
    return _helics.helicsEndpointGetName(endpoint, str)

def helicsFederateGetEndpointCount(fed):
    return _helics.helicsFederateGetEndpointCount(fed)
helicsFederateGetEndpointCount = _helics.helicsFederateGetEndpointCount

def helicsFederateRegisterSourceFilter(fed, type, target, name):
    """


    create a source Filter on the specified federate

    filters can be created through a federate or a core , linking through a federate
    allows a few extra features of name matching to function on the federate
    interface but otherwise equivalent behavior

    Parameters
    ----------
    * `fed` :
        the fed to register through
    * `name` :
        the name of the filter (can be nullptr)
    * `inputType` :
        the input type of the filter, used for ordering (can be nullptr)
    * `outputType` :
        the output type of the filter, used for ordering (can be nullptr)

    Returns
    -------
    a helics_source_filter object

    """
    return _helics.helicsFederateRegisterSourceFilter(fed, type, target, name)

def helicsFederateRegisterDestinationFilter(fed, type, target, name):
    """


    """
    return _helics.helicsFederateRegisterDestinationFilter(fed, type, target, name)

def helicsFederateRegisterCloningFilter(fed, deliveryEndpoint):
    """


    """
    return _helics.helicsFederateRegisterCloningFilter(fed, deliveryEndpoint)

def helicsCoreRegisterSourceFilter(core, type, target, name):
    """


    """
    return _helics.helicsCoreRegisterSourceFilter(core, type, target, name)

def helicsCoreRegisterDestinationFilter(core, type, target, name):
    """


    """
    return _helics.helicsCoreRegisterDestinationFilter(core, type, target, name)

def helicsCoreRegisterCloningFilter(fed, deliveryEndpoint):
    """


    """
    return _helics.helicsCoreRegisterCloningFilter(fed, deliveryEndpoint)

def helicsFilterGetTarget(filt, str):
    """


    get the target of the filter

    """
    return _helics.helicsFilterGetTarget(filt, str)

def helicsFilterGetName(filt, str):
    """


    get the name of the filter

    """
    return _helics.helicsFilterGetName(filt, str)

def helicsFilterSet(filt, property, val):
    """


    """
    return _helics.helicsFilterSet(filt, property, val)

def helicsFilterSetString(filt, property, val):
    return _helics.helicsFilterSetString(filt, property, val)
helicsFilterSetString = _helics.helicsFilterSetString

def helicsFilterAddDestinationTarget(filt, dest):
    """


    """
    return _helics.helicsFilterAddDestinationTarget(filt, dest)

def helicsFilterAddSourceTarget(filt, source):
    """


    """
    return _helics.helicsFilterAddSourceTarget(filt, source)

def helicsFilterAddDeliveryEndpoint(filt, deliveryEndpoint):
    """


    """
    return _helics.helicsFilterAddDeliveryEndpoint(filt, deliveryEndpoint)

def helicsFilterRemoveDestinationTarget(filt, dest):
    """


    """
    return _helics.helicsFilterRemoveDestinationTarget(filt, dest)

def helicsFilterRemoveSourceTarget(filt, source):
    """


    """
    return _helics.helicsFilterRemoveSourceTarget(filt, source)

def helicsFilterRemoveDeliveryEndpoint(filt, deliveryEndpoint):
    """


    """
    return _helics.helicsFilterRemoveDeliveryEndpoint(filt, deliveryEndpoint)
# This file is compatible with both classic and new-style classes.


